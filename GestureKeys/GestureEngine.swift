import AppKit
import CoreGraphics

// MARK: - Global State (required for @convention(c) callbacks)

/// Lock protecting access to the engine instance from callback threads
private var engineLock = os_unfair_lock()

/// Singleton engine instance, accessed from C callbacks
private var engineInstance: GestureEngine?

/// Global multitouch callback function (cannot capture context).
/// Uses UnsafeMutableRawPointer because MTTouch isn't directly representable in @convention(c).
private func touchCallback(
    device: MTDeviceRef,
    rawTouches: UnsafeMutableRawPointer,
    touchCount: Int32,
    timestamp: Double,
    frame: Int32
) {
    os_unfair_lock_lock(&engineLock)
    let engine = engineInstance
    os_unfair_lock_unlock(&engineLock)

    let touches = rawTouches.assumingMemoryBound(to: MTTouch.self)
    engine?.processTouches(touches, count: Int(touchCount), timestamp: timestamp)
}

/// Global CGEventTap callback for intercepting mouse clicks
private func eventTapCallback(
    proxy: CGEventTapProxy,
    type: CGEventType,
    event: CGEvent,
    refcon: UnsafeMutableRawPointer?
) -> Unmanaged<CGEvent>? {
    // Handle tap being disabled by the system.
    if type == .tapDisabledByTimeout || type == .tapDisabledByUserInput {
        os_unfair_lock_lock(&engineLock)
        let engine = engineInstance
        os_unfair_lock_unlock(&engineLock)
        engine?.reEnableEventTap()
        engine?.trackTapDisabled()
        return Unmanaged.passUnretained(event)
    }

    // Shift + brightness key → keyboard backlight (no lock needed)
    if type.rawValue == 14 {  // NX_SYSDEFINED
        if event.flags.contains(.maskShift),
           let nsEvent = NSEvent(cgEvent: event),
           nsEvent.subtype.rawValue == 8 {  // special key event
            let data1 = nsEvent.data1
            let keyType = (data1 >> 16) & 0xFF
            if keyType == 2 || keyType == 3 {  // brightness up/down
                let isDown = (data1 & 0xFF00) == 0x0A00
                if isDown {
                    if keyType == 2 {
                        KeySynthesizer.postKbBrightnessUp()
                    } else {
                        KeySynthesizer.postKbBrightnessDown()
                    }
                }
                return nil  // consume both down and up
            }
        }
        return Unmanaged.passUnretained(event)
    }

    // Safe engine reference via engineLock (avoids use-after-free during shutdown)
    os_unfair_lock_lock(&engineLock)
    guard let engine = engineInstance else {
        os_unfair_lock_unlock(&engineLock)
        return Unmanaged.passUnretained(event)
    }
    os_unfair_lock_unlock(&engineLock)

    // Track keyboard events for precise typing suppression
    if type == .keyDown || type == .flagsChanged {
        let now = ProcessInfo.processInfo.systemUptime
        let timeSinceSynthesis = now - KeySynthesizer.lastSynthesisTimestamp
        // Only record if this event was NOT generated by our own key synthesis
        if timeSinceSynthesis > 0.05 {
            os_unfair_lock_lock(&engineLock)
            engine.lastExternalKeyTime = now
            // Typing burst tracking
            let burstWindow: TimeInterval = 2.0
            if now - engine.burstStartTime > burstWindow {
                engine.keystrokeCount = 1
                engine.burstStartTime = now
                engine.typingBurstActive = false
            } else {
                engine.keystrokeCount += 1
                if engine.keystrokeCount >= 5 {
                    engine.typingBurstActive = true
                }
            }
            os_unfair_lock_unlock(&engineLock)
        }
        return Unmanaged.passUnretained(event)
    }

    guard type == .leftMouseDown else {
        return Unmanaged.passUnretained(event)
    }

    os_unfair_lock_lock(&engineLock)
    var shouldSuppress = false

    // 5-finger click has highest priority (most fingers, least ambiguous)
    shouldSuppress = engine.fiveFingerClickRecognizer.handlePhysicalClick()
    if shouldSuppress {
        // 5FC consumed the click — reset competing 5-finger recognizers
        engine.fiveFingerTapRecognizer.reset()
        engine.fiveFingerLongPressRecognizer.reset()
    }

    // 4-finger click (no conflict with other gestures)
    if !shouldSuppress {
        shouldSuppress = engine.fourFingerRecognizer.handlePhysicalClick()
    }

    if !shouldSuppress {
        // 3FC has highest priority among 3-finger gestures.
        // Physical click is the strongest intent signal — always attempt 3FC.
        shouldSuppress = engine.threeFingerRecognizer.handlePhysicalClick()
        if shouldSuppress {
            // 3FC consumed the click — reset all competing recognizers
            engine.tapWhileHoldingRecognizer.reset()
            engine.swipeWhileHoldingRecognizer.reset()
            engine.longPressWhileHoldingRecognizer.reset()
            engine.threeFingerDoubleTapRecognizer.reset()
            engine.threeFingerLongPressRecognizer.reset()
            engine.threeFingerSwipeRecognizer.reset()
        }
    }
    let pendingActions = KeySynthesizer.takePendingActions()
    os_unfair_lock_unlock(&engineLock)
    for action in pendingActions { action() }

    if shouldSuppress {
        return nil
    }

    return Unmanaged.passUnretained(event)
}

// MARK: - GestureEngine

/// Central orchestrator that manages multitouch device lifecycle,
/// routes touch data to gesture recognizers, and manages the CGEventTap.
final class GestureEngine {

    // MARK: Notifications

    /// Posted when CGEventTap creation fails at startup.
    static let eventTapFailedNotification = Notification.Name("GestureKeysEventTapFailed")

    /// Posted when the system repeatedly disables the EventTap (likely stale permission).
    static let permissionIssueNotification = Notification.Name("GestureKeysPermissionIssue")

    /// When true, gestures are recognized but not executed (test mode).
    static var monitorMode = false

    /// True if CGEventTap was successfully installed.
    private(set) var eventTapActive = false

    let threeFingerRecognizer = ThreeFingerClickRecognizer()
    let fourFingerRecognizer = FourFingerClickRecognizer()
    let tapWhileHoldingRecognizer = TapWhileHoldingRecognizer()
    let swipeWhileHoldingRecognizer = SwipeWhileHoldingRecognizer()
    let longPressWhileHoldingRecognizer = LongPressWhileHoldingRecognizer()
    let threeFingerDoubleTapRecognizer = ThreeFingerDoubleTapRecognizer()
    let threeFingerLongPressRecognizer = ThreeFingerLongPressRecognizer()
    let fourFingerDoubleTapRecognizer = FourFingerDoubleTapRecognizer()
    let fourFingerLongPressRecognizer = FourFingerLongPressRecognizer()
    let fiveFingerTapRecognizer = FiveFingerTapRecognizer()
    let fiveFingerClickRecognizer = FiveFingerClickRecognizer()
    let fiveFingerLongPressRecognizer = FiveFingerLongPressRecognizer()
    let threeFingerSwipeRecognizer = ThreeFingerSwipeRecognizer()
    let oneFingerHoldTapRecognizer = OneFingerHoldTapRecognizer()
    let oneFingerHoldSwipeRecognizer = OneFingerHoldSwipeRecognizer()
    let twoFingerSwipeRecognizer = TwoFingerSwipeRecognizer()
    let twoFingerTapRecognizer = TwoFingerTapRecognizer()

    private var devices: [MTDeviceRef] = []
    private var eventTap: CFMachPort?
    private var runLoopSource: CFRunLoopSource?
    private var isRunning = false
    private var deviceRecoveryTimer: Timer?

    /// True when Mission Control, Exposé, or Spaces transition is active.
    /// Updated on main thread via workspace notification; read from touch callback.
    private var systemUIActive = false

    /// Timestamp of the last externally-generated keyboard event (not our synthesis).
    /// Updated in the CGEventTap callback under `engineLock`. Used for typing suppression.
    fileprivate var lastExternalKeyTime: TimeInterval = 0

    /// Number of keystrokes in the current typing burst (for burst detection).
    fileprivate var keystrokeCount: Int = 0

    /// Timestamp of the first keystroke in the current burst window.
    fileprivate var burstStartTime: TimeInterval = 0

    /// True when a typing burst has been detected (extends suppression window).
    fileprivate var typingBurstActive = false

    /// Tracks timestamps of consecutive tapDisabledByTimeout events for S3 detection.
    private var tapDisabledTimestamps: [TimeInterval] = []

    /// Prevents duplicate permission issue alerts.
    private var permissionIssuePosted = false

    func start() {
        guard !isRunning else { return }

        os_unfair_lock_lock(&engineLock)
        engineInstance = self
        os_unfair_lock_unlock(&engineLock)

        startMultitouchDevices()
        installEventTap()
        startDeviceRecovery()
        observeSystemUI()
        isRunning = true

        NSLog("GestureKeys: Engine started with %d device(s)", devices.count)
    }

    func stop() {
        guard isRunning else { return }

        NSWorkspace.shared.notificationCenter.removeObserver(self)
        deviceRecoveryTimer?.invalidate()
        deviceRecoveryTimer = nil
        // Order matters: remove event tap first so callbacks can't fire on stopped devices.
        removeEventTap()
        stopMultitouchDevices()

        os_unfair_lock_lock(&engineLock)
        engineInstance = nil
        resetAllRecognizers()
        os_unfair_lock_unlock(&engineLock)

        isRunning = false

        NSLog("GestureKeys: Engine stopped")
    }

    /// Resets all gesture recognizers to idle state.
    /// Must be called while `engineLock` is held.
    private func resetAllRecognizers() {
        threeFingerRecognizer.reset()
        fourFingerRecognizer.reset()
        tapWhileHoldingRecognizer.reset()
        swipeWhileHoldingRecognizer.reset()
        longPressWhileHoldingRecognizer.reset()
        threeFingerDoubleTapRecognizer.reset()
        threeFingerLongPressRecognizer.reset()
        fourFingerDoubleTapRecognizer.reset()
        fourFingerLongPressRecognizer.reset()
        fiveFingerTapRecognizer.reset()
        fiveFingerClickRecognizer.reset()
        fiveFingerLongPressRecognizer.reset()
        threeFingerSwipeRecognizer.reset()
        oneFingerHoldTapRecognizer.reset()
        oneFingerHoldSwipeRecognizer.reset()
        twoFingerSwipeRecognizer.reset()
        twoFingerTapRecognizer.reset()
    }

    /// Timestamp of the last reEnableEventTap log (throttle to every 5 seconds).
    private var lastReEnableLogTime: TimeInterval = 0

    /// Re-enables the event tap if the system disabled it
    func reEnableEventTap() {
        if let tap = eventTap {
            CGEvent.tapEnable(tap: tap, enable: true)
            let now = ProcessInfo.processInfo.systemUptime
            if now - lastReEnableLogTime > 5.0 {
                NSLog("GestureKeys: Event tap re-enabled")
                lastReEnableLogTime = now
            }
        }
    }

    /// Tracks repeated tapDisabledByTimeout events.
    /// If 3+ disables within 10 seconds, the permission is likely stale (rebuild).
    func trackTapDisabled() {
        let now = ProcessInfo.processInfo.systemUptime
        tapDisabledTimestamps.append(now)
        // Keep only events within the last 10 seconds
        tapDisabledTimestamps = tapDisabledTimestamps.filter { now - $0 < 10.0 }

        if tapDisabledTimestamps.count >= 3 && !permissionIssuePosted {
            permissionIssuePosted = true
            NSLog("GestureKeys: EventTap disabled %d times in 10s — likely stale permission", tapDisabledTimestamps.count)
            DispatchQueue.main.async {
                NotificationCenter.default.post(name: Self.permissionIssueNotification, object: nil)
            }
        }
    }

    // MARK: - Touch Processing

    func processTouches(_ touchPtr: UnsafeMutablePointer<MTTouch>, count: Int, timestamp: Double) {
        // Single-pass filter from raw buffer (1 allocation instead of 2)
        let activeTouches = UnsafeBufferPointer(start: touchPtr, count: count).filter { $0.touchState.isActive }
        let activeCount = activeTouches.count

        // Note: monitorMode is read without engineLock intentionally.
        // Bool read/write is atomic on ARM64. Worst case: 1-2 frames of
        // data missed during monitor mode transition — functionally harmless.
        if Self.monitorMode {
            GestureMonitor.shared.updateTouchCount(activeCount)
            GestureMonitor.shared.logTouchSizes(activeTouches)
        }

        os_unfair_lock_lock(&engineLock)

        // Suppress gestures during Mission Control / Exposé / Spaces transition
        if systemUIActive {
            resetAllRecognizers()
            os_unfair_lock_unlock(&engineLock)
            return
        }

        // Pre-compute typing suppression values (used in 3 suppression checks below)
        let config = GestureConfig.shared
        let now = ProcessInfo.processInfo.systemUptime
        let timeSinceTyping = now - lastExternalKeyTime
        let hasPeripheralTouch = config.cachedTypingSupprEnabled
            && activeTouches.contains { $0.isTypingEdge || $0.isPalmSized }

        // Typing suppression (palm rejection): zone-aware.
        // Only suppress peripheral/palm touches during typing window.
        if config.cachedTypingSupprEnabled {
            let baseWindow = config.cachedTypingSupprWindow
            let window = typingBurstActive ? max(baseWindow, 0.4) : baseWindow

            if timeSinceTyping < window && hasPeripheralTouch {
                resetAllRecognizers()
                os_unfair_lock_unlock(&engineLock)
                return
            }

            // Decay burst state after sustained silence
            if timeSinceTyping > 3.0 {
                typingBurstActive = false
                keystrokeCount = 0
            }
        }
        // Click-based recognizers (skip when idle and below finger threshold)
        if activeCount >= 3 || threeFingerRecognizer.state != .idle {
            threeFingerRecognizer.processTouches(activeTouches, timestamp: timestamp)
        }
        if activeCount >= 4 || fourFingerRecognizer.state != .idle {
            fourFingerRecognizer.processTouches(activeTouches, timestamp: timestamp)
        }
        if activeCount >= 5 || fiveFingerClickRecognizer.state != .idle {
            fiveFingerClickRecognizer.processTouches(activeTouches, timestamp: timestamp)
        }

        // 2-finger hold recognizers: suppress peripheral/palm touches during extended typing window
        let twoFingerSuppressed = hasPeripheralTouch
            && timeSinceTyping < max(config.cachedTypingSupprWindow * 1.2, 0.4)

        if twoFingerSuppressed {
            tapWhileHoldingRecognizer.reset()
            swipeWhileHoldingRecognizer.reset()
            longPressWhileHoldingRecognizer.reset()
        } else {
            // Hold + tap/double-tap
            tapWhileHoldingRecognizer.processTouches(activeTouches, timestamp: timestamp)

            // Hold + swipe (fires reset TWH on swipe)
            let swipeFired = swipeWhileHoldingRecognizer.processTouches(activeTouches, timestamp: timestamp)
            if swipeFired {
                tapWhileHoldingRecognizer.reset()
                longPressWhileHoldingRecognizer.reset()
            }

            // Hold + long press (fires reset TWH and SWH)
            let longPressFired = longPressWhileHoldingRecognizer.processTouches(activeTouches, timestamp: timestamp)
            if longPressFired {
                tapWhileHoldingRecognizer.reset()
                swipeWhileHoldingRecognizer.reset()
            }
        }

        // 3-finger gestures (skip when all idle and below finger threshold)
        // 3FC (click) has highest priority — never reset by other 3-finger recognizers.
        if activeCount >= 3 || threeFingerDoubleTapRecognizer.state != .idle || threeFingerLongPressRecognizer.state != .idle || threeFingerSwipeRecognizer.state != .idle {
            let threeFingerSwipeFired = threeFingerSwipeRecognizer.processTouches(activeTouches, timestamp: timestamp)
            if threeFingerSwipeFired {
                // Swipe resets double-tap and long-press, but NOT 3FC
                threeFingerDoubleTapRecognizer.reset()
                threeFingerLongPressRecognizer.reset()
            }
            threeFingerDoubleTapRecognizer.processTouches(activeTouches, timestamp: timestamp)
            threeFingerLongPressRecognizer.processTouches(activeTouches, timestamp: timestamp)
            if threeFingerLongPressRecognizer.state == .fired {
                threeFingerDoubleTapRecognizer.reset()
                threeFingerSwipeRecognizer.reset()
            }
        }

        // 4-finger gestures (skip when all idle and below finger threshold)
        if activeCount >= 4 || fourFingerDoubleTapRecognizer.state != .idle || fourFingerLongPressRecognizer.state != .idle {
            fourFingerDoubleTapRecognizer.processTouches(activeTouches, timestamp: timestamp)
            fourFingerLongPressRecognizer.processTouches(activeTouches, timestamp: timestamp)
            if fourFingerLongPressRecognizer.state == .fired {
                fourFingerDoubleTapRecognizer.reset()
            }
        }

        // 5-finger gestures (skip when all idle and below finger threshold)
        if activeCount >= 5 || fiveFingerTapRecognizer.state != .idle || fiveFingerLongPressRecognizer.state != .idle {
            let tapFired = fiveFingerTapRecognizer.processTouches(activeTouches, timestamp: timestamp)
            fiveFingerLongPressRecognizer.processTouches(activeTouches, timestamp: timestamp)
            // Mutual exclusion: whichever fires first resets the others
            if tapFired {
                fiveFingerClickRecognizer.reset()
                fiveFingerLongPressRecognizer.reset()
            }
            if fiveFingerLongPressRecognizer.state == .fired {
                fiveFingerTapRecognizer.reset()
                fiveFingerClickRecognizer.reset()
            }
        }

        // Deferred display sleep: execute after fingers lift to prevent trackpad wake
        if fiveFingerLongPressRecognizer.consumeLiftEvent() {
            KeySynthesizer.pendingActions.append { KeySynthesizer.postSleepDisplay() }
        }

        // 1-finger hold + tap / swipe: suppress peripheral/palm touches during wider typing window
        let oneFingerSuppressed = hasPeripheralTouch
            && timeSinceTyping < max(config.cachedTypingSupprWindow * 1.5, 0.5)

        if oneFingerSuppressed {
            oneFingerHoldTapRecognizer.reset()
            oneFingerHoldSwipeRecognizer.reset()
        } else {
            // Pass keyboard timestamp so recognizers can reject holds during typing
            oneFingerHoldTapRecognizer.lastExternalKeyTime = lastExternalKeyTime
            oneFingerHoldSwipeRecognizer.lastExternalKeyTime = lastExternalKeyTime
            oneFingerHoldTapRecognizer.processTouches(activeTouches, timestamp: timestamp)
            let ofhSwipeFired = oneFingerHoldSwipeRecognizer.processTouches(activeTouches, timestamp: timestamp)
            if ofhSwipeFired {
                oneFingerHoldTapRecognizer.reset()
            }
        }

        // 2-finger standalone recognizers: also suppress during typing
        if twoFingerSuppressed {
            twoFingerSwipeRecognizer.reset()
            twoFingerTapRecognizer.reset()
        } else {
            // 2-finger swipe (back/forward)
            let twoFingerSwipeFired = twoFingerSwipeRecognizer.processTouches(activeTouches, timestamp: timestamp)
            if twoFingerSwipeFired {
                oneFingerHoldTapRecognizer.reset()
                oneFingerHoldSwipeRecognizer.reset()
                twoFingerTapRecognizer.reset()
            }

            // 2-finger double tap (copy)
            twoFingerTapRecognizer.processTouches(activeTouches, timestamp: timestamp)
        }
        let pendingActions = KeySynthesizer.takePendingActions()
        os_unfair_lock_unlock(&engineLock)
        for action in pendingActions { action() }
    }

    // MARK: - Multitouch Device Management

    private func startMultitouchDevices() {
        let rawList = MTDeviceCreateList()
        let count = CFArrayGetCount(rawList)

        if count == 0 {
            NSLog("GestureKeys: No multitouch devices found")
            return
        }

        for i in 0..<count {
            guard let rawPtr = CFArrayGetValueAtIndex(rawList, i) else { continue }
            let device = MTDeviceRef(rawPtr)
            MTRegisterContactFrameCallback(device, touchCallback)
            MTDeviceStart(device, 0)
            devices.append(device)
        }
    }

    private func stopMultitouchDevices() {
        for device in devices {
            MTUnregisterContactFrameCallback(device, touchCallback)
            MTDeviceStop(device)
        }
        devices.removeAll()
    }

    // MARK: - CGEventTap Management

    private func installEventTap() {
        let tap = CGEvent.tapCreate(
            tap: .cghidEventTap,
            place: .headInsertEventTap,
            options: .defaultTap,
            eventsOfInterest: CGEventMask(
                (1 << CGEventType.leftMouseDown.rawValue) |
                (1 << CGEventType.keyDown.rawValue) |
                (1 << CGEventType.flagsChanged.rawValue) |
                (1 << 14)  // NX_SYSDEFINED — media/brightness keys
            ),
            callback: eventTapCallback,
            userInfo: nil
        )

        guard let tap = tap else {
            NSLog("GestureKeys: Failed to create CGEventTap (check Accessibility permissions)")
            eventTapActive = false
            DispatchQueue.main.async {
                NotificationCenter.default.post(name: Self.eventTapFailedNotification, object: nil)
            }
            return
        }

        eventTap = tap
        eventTapActive = true
        permissionIssuePosted = false
        tapDisabledTimestamps.removeAll()
        NSLog("GestureKeys: CGEventTap created successfully")

        let source = CFMachPortCreateRunLoopSource(kCFAllocatorDefault, tap, 0)
        runLoopSource = source
        CFRunLoopAddSource(CFRunLoopGetMain(), source, .commonModes)
        CGEvent.tapEnable(tap: tap, enable: true)
    }

    private func removeEventTap() {
        if let source = runLoopSource {
            CFRunLoopRemoveSource(CFRunLoopGetMain(), source, .commonModes)
            runLoopSource = nil
        }
        if let tap = eventTap {
            CGEvent.tapEnable(tap: tap, enable: false)
            eventTap = nil
        }
        eventTapActive = false
    }

    // MARK: - System UI Detection

    private func observeSystemUI() {
        let center = NSWorkspace.shared.notificationCenter
        center.addObserver(
            self, selector: #selector(activeAppChanged),
            name: NSWorkspace.didActivateApplicationNotification, object: nil
        )
        // Also detect space changes (Spaces / full-screen transitions)
        center.addObserver(
            self, selector: #selector(activeAppChanged),
            name: NSWorkspace.activeSpaceDidChangeNotification, object: nil
        )
    }

    @objc private func activeAppChanged(_ notification: Notification) {
        let bundleId = NSWorkspace.shared.frontmostApplication?.bundleIdentifier
        let isDock = bundleId == "com.apple.dock"
        os_unfair_lock_lock(&engineLock)
        systemUIActive = isDock
        if bundleId != "com.gesturekeys.app" {
            GestureConfig.shared.lastExternalBundleId = bundleId
        }
        GestureConfig.shared.cachedFrontmostBundleId = bundleId
        if isDock { resetAllRecognizers() }
        os_unfair_lock_unlock(&engineLock)
    }

    // MARK: - Device Recovery

    private func startDeviceRecovery() {
        deviceRecoveryTimer = Timer.scheduledTimer(withTimeInterval: 5.0, repeats: true) { [weak self] _ in
            guard let self, self.isRunning else { return }
            // MTDeviceCreateList() returns a CFArray. In Swift, it's automatically
            // managed via toll-free bridging. The local binding ensures ARC releases
            // it when this closure scope exits.
            let rawList = MTDeviceCreateList()
            let currentCount = CFArrayGetCount(rawList)
            if currentCount != self.devices.count {
                NSLog("GestureKeys: Device count changed (%d → %ld), re-registering", self.devices.count, currentCount)
                self.stopMultitouchDevices()
                self.startMultitouchDevices()
            }
        }
    }
}
